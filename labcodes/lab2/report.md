# ================================================================================================================
# ================================================================================================================
#                                  操作系统实验 ucore Lab2 实验报告
# ================================================================================================================
# ================================================================================================================

[练习1]  实现 first-fit 连续物理内存分配算法
# ----------------------------------------------------------------------------------------------------------------
我们需要实现内存分配的4个操作：初始化，memmap初始化，页分配，页释放。
# --------------初始化-----------------------------
实现函数：default_init
实现策略：调用list初始化函数，将空闲块数量设为0.
# --------------memmap初始化-----------------------
实现函数：default_init_memmap(base, n)
base : 内存块的头部
n : 页的数量
实现策略：
(1) 对于块中的每个页，将属性(property)设为0.标志(flag)通过函数SetPageProperty设为PG_property。引用(ref)设为0。处理完毕后加入free_list中。
(2) 将第一页的属性设为块的大小。空闲块数量增加块的大小。
# --------------页分配-----------------------------
实现函数：default_alloc_pages(base, n)
base : 内存块的头部
n : 页的数量
实现策略：
(1) 找到第一个空间大于n的块。
(2) 对于这个块的前n个页，将保留(reserved)设为1，属性设为0，然后从free_list中删除。
(3) 若这个块的大小大于n，上述步骤完成后还剩余空闲块，此时应该设新的页头，属性设为剩余页的大小。
(4) 空闲块数量减少块的大小。
(5) 返回找到的页头。
# --------------页释放-----------------------------
实现函数：default_free_pages(base, n)
base : 内存块的头部
n : 页的数量
实现策略：
(1) 找到列表中第一个地址比要删除的块大的页。
(2) 将释放的块中的所有页放在所找到的页的前面。
(3) 将块中的页头标志设为0，属性设为块大小，引用设为0。
(4) 检查是否和下一个块相邻，并向后合并。
(5) 检查是否和上一个块相邻，并向前合并。
# -------------------------------------------------
[问题1]  你的first fit算法是否有进一步的改进空间
(1) 表内的无用页（属性为0）太多，严重影响了效率，可以考虑将块中的页合并的策略，这样可以提高链表的利用率。
(2) 
[练习2]  实现寻找虚拟地址对应的页表项
# ----------------------------------------------------------------------------------------------------------------
主要是完成get_pte函数。
pte_t* get_pte(pde_t *pgdir, uintptr_t la, bool create) 
{
#   通过一级页表pgdir，来获得二级页表pdepage
    pde_t *pdep = &pgdir[PDX(la)];
#   二级页表pdepage不存在时
    if (!(*pdep & PTE_P)) 
    {
       	struct Page *page;
#		分配新的页
       	if (!create || (page = alloc_page()) == NULL) 
           	return NULL;
#		设置引用标志为1
      	set_page_ref(page, 1);
#		设置Present标志，可写标志，用户权限标志
       	uintptr_t pa = page2pa(page);
      	memset(KADDR(pa), 0, PGSIZE);
       	*pdep = pa | PTE_U | PTE_W | PTE_P;
    }
#	存在则直接返回地址
    return &((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];
}



[练习3]  释放某虚地址所在的页并取消对应二级页表项的映射
# ----------------------------------------------------------------------------------------------------------------
主要是完成page_remove_pte函数
static inline void
page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) 
{
#	当二级页表存在时
    if (*ptep & PTE_P) {
#		根据页表查到相应的页
    	struct Page *page = pte2page(*ptep);
#		当引用标志为0时，说明没有映射到其他的页，释放该页
       	if (page_ref_dec(page) == 0) 
           	free_page(page);
#		将页表相应表项设为0
       	*ptep = 0;
#		更新TLB表
       	tlb_invalidate(pgdir, la);
    }
}


